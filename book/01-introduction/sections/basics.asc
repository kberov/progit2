=== Основи на Гит

Е, какво е Гит всъщност? Това е важно да се разбере, защото ако знаете какво е Гит и как работи в общи линии,
то може би ще ви бъде по-лесно да я ползвате ефективно. Като изучавате Гит се опитайте да изчистите съзнанието
си от нещата, които знаете за други СУВ като Subversion и Perforce. Така ще избегнете ненужни обърквания,
докато ползвате системата. Гит съхранява и мисли за данните по различен начин, макар потребителския интерфейс
да е подобен. Разбирането на разликите ще ви спести неудобства докато ползвате
системата.(((Subversion)))(((Perforce)))

==== Снимки, Не Разлики

Главната разлика между Гит и всяка друга СУВ (Subversion и приятели включително) е начининът, по който Гит
мисли за данните си. Повечето други системи съхраняват данните си като списък от промени върху файлове. Тези
системи (CVS, Subversion, Perforce, Bazaar и т.н.) мислят за данните, които съхраняват като набор от файлове и
промени, направени върху всеки от тези файлове в течение на времето.

.Съхраняване на данни като промени върху една първична версия на всеки файл.
image::images/deltas.png[Съхраняване на данни като промени върху една първична версия на всеки файл.]

Гит не мисли за данните си, нито ги съхранява, по този начин. Вместо това Гит гледа на данните като на набор
от състояния на малка файлова система. Всеки път, когато подадете файлове или запишете състоянието на
вашия проект в Гит, тя всъщност прави снимка на вашите файлове в момента и съхранява указател към това
състояние. Ако няма променени файлове, Гит не съхранява файла отново, а просто връзка към предишното
състояние на същия файл, който вече е съхранила. Това се прави с цел ефективност. Гит разглежда данните си
като поток от *моментни снимки (състояния)*.

.Съхраняване на данните като снимки на проекта във времето.
image::images/snapshots.png[Съхраняване на данните като снимки на проекта във времето.]

Това е важна разлика между Гит и почти всички други СУВ. Гит преразглежда почти всяко положение на
управлението на версиите, докато повечето системи копират от предното поколение. Това превръща Гит
по-скоро във мини-файлова система с набор от изключително мощни инструменти, нежели обичайна СУВ. Ще
разгледаме някои от предимствата на това да се мисли за данните по този начин, когато обсъждаме разклоняването
в <<_git_branching>>.

==== Почти Всяко Действие е Самостоятелно

Повечето действия в Гит се нуждаят само от файлове и ресурси на вашия компютър – като цяло няма нужда от
каквато и да е информация извън него. Ако сте свикнали със СУВ, където почти всяко действие зависи от мрежата,
тази страна на Гит ще ви накара да си мислите, че боговете на скоростта са я благословили с неописуема мощ.
Повечето действия се изпълняват мигновено, защото цялата история на проекта е на вашия твърд диск.

Например ако разглеждате историята на проекта, Гит не трябва да прави заявка към сървър, за да вземе историята
и да ви я покаже. Тя просто я чете от собствената си база данни. Като следствие виждате историята почти
мигновено. Ако искате да видите направените промени в даден файл отпреди месец, Гит поглежда състоянието на
файла отпреди месец и изчислява разликите вместо да прави заявка към отдалечен сървър за това или да взема
стара версия на файла от сървъра, за да го сравни с текущата версия на вашия компютър. 

Това означава също, че можете да правите почти всичко дори ако сте извън линия или извън вашата виртуална
частна мрежа (ВЧМ). Ако сте в самолет или влак, можете да подавате промени спокойно и да качите промените
когато се доберете до мрежа. Ако сте вкъщи и не успеете да настроите ВЧМ, все пак можете да работите. При
много други системи това е или невъзможно или мъчително. С Perforce например не можете да направите много ако
не сте свързани със сървъра, а със Subversion и CVS можете да променяте файлове, но не можете да подадете
промените в базата данни (защото сте извън линия). Това може и да ви изглежда, че не е кой знае какъв проблем,
но ще се изненадате като усетите разликата.

==== Гит е Цялостно Решение

Преди да се съхрани каквото и да е в Гит, то получава хеш-сума (указател) и след това указателят се ползва за
достъп до съхраненото. Това означава, че е невъзможно да промените съдържанието на файл или папка без Гит
да знае за това. Тази способност е вградена в Гит на най-ниско ниво и е неразделна част от философията на
системата. Невъзможно е да загубите данни или да повредите файл, без Гит да може да засече това.

The mechanism that Git uses for this checksumming is called a SHA-1 hash.(((SHA-1)))
This is a 40-character string composed of hexadecimal characters (0–9 and a–f) and calculated based on the contents of a file or directory structure in Git.
A SHA-1 hash looks something like this:

[source]
----
24b9da6552252987aa493b52f8696cd6d3b00373
----

You will see these hash values all over the place in Git because it uses them so much.
In fact, Git stores everything in its database not by file name but by the hash value of its contents.

==== Git Generally Only Adds Data

When you do actions in Git, nearly all of them only add data to the Git database.
It is hard to get the system to do anything that is not undoable or to make it erase data in any way.
As in any VCS, you can lose or mess up changes you haven't committed yet; but after you commit a snapshot into Git, it is very difficult to lose, especially if you regularly push your database to another repository.

This makes using Git a joy because we know we can experiment without the danger of severely screwing things up.
For a more in-depth look at how Git stores its data and how you can recover data that seems lost, see <<_undoing>>.

==== The Three States

Now, pay attention.
This is the main thing to remember about Git if you want the rest of your learning process to go smoothly.
Git has three main states that your files can reside in: committed, modified, and staged.
Committed means that the data is safely stored in your local database.
Modified means that you have changed the file but have not committed it to your database yet.
Staged means that you have marked a modified file in its current version to go into your next commit snapshot.

This leads us to the three main sections of a Git project: the Git directory, the working tree, and the staging area.

.Working tree, staging area, and Git directory.
image::images/areas.png["Working tree, staging area, and Git directory."]

The Git directory is where Git stores the metadata and object database for your project.
This is the most important part of Git, and it is what is copied when you clone a repository from another computer.

The working tree is a single checkout of one version of the project.
These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify.

The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit.
It's sometimes referred to as the ``index'', but it's also common to refer to it as the staging area.

The basic Git workflow goes something like this:

1. You modify files in your working tree.
2. You stage the files, adding snapshots of them to your staging area.
3. You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory.

If a particular version of a file is in the Git directory, it's considered committed.
If it has been modified and was added to the staging area, it is staged.
And if it was changed since it was checked out but has not been staged, it is modified.
In <<_git_basics_chapter>>, you'll learn more about these states and how you can either take advantage of them or skip the staged part entirely.
